// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 Huang Rui <vowstar@gmail.com>

#include "common/qsocgeneratemanager.h"
#include "common/qsocgenerateprimitiveclock.h"
#include "common/qsocgenerateprimitivecomb.h"
#include "common/qsocgenerateprimitiveseq.h"
#include "common/qsocgeneratereportunconnected.h"
#include "common/qstaticstringweaver.h"
#include "qsocgenerateprimitivefsm.h"
#include "qsocgenerateprimitivereset.h"

#include <QCoreApplication>
#include <QDebug>
#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QProcess>
#include <QRegularExpression>
#include <QTextStream>

#include <fstream>
#include <iostream>

bool QSocGenerateManager::generateVerilog(const QString &outputFileName)
{
    /* Create unconnected port reporter for collecting data */
    QSocGenerateReportUnconnected unconnectedPortReporter;

    /* Check if netlistData is valid (instance section is now optional) */

    // Check if instance section exists and is valid when present
    if (netlistData["instance"] && !netlistData["instance"].IsMap()) {
        qCritical() << "Error: Invalid netlist data, 'instance' section is not a map";
        return false;
    }

    // Allow empty or missing instance section if comb, seq, or fsm section exists
    bool hasInstances = netlistData["instance"] && netlistData["instance"].IsMap()
                        && netlistData["instance"].size() > 0;
    bool hasCombSeqFsm = netlistData["comb"] || netlistData["seq"] || netlistData["fsm"];
    bool hasReset      = netlistData["reset"] && netlistData["reset"].IsSequence()
                    && netlistData["reset"].size() > 0;
    bool hasClock = netlistData["clock"] && netlistData["clock"].IsSequence()
                    && netlistData["clock"].size() > 0;

    if (!hasInstances && !hasCombSeqFsm && !hasReset && !hasClock) {
        qCritical() << "Error: Invalid netlist data, no 'instance' section and no 'comb', "
                       "'seq', 'fsm', 'reset', or 'clock' section found";
        return false;
    }

    /* Check if net section exists and has valid format if present */
    if (netlistData["net"] && !netlistData["net"].IsMap()) {
        qCritical() << "Error: Invalid netlist data, 'net' section is not a map";
        return false;
    }

    /* Check if project manager is valid */
    if (!projectManager) {
        qCritical() << "Error: Project manager is null";
        return false;
    }

    if (!projectManager->isValidOutputPath(true)) {
        qCritical() << "Error: Invalid output path: " << projectManager->getOutputPath();
        return false;
    }

    /* Prepare output file path */
    const QString outputFilePath
        = QDir(projectManager->getOutputPath()).filePath(outputFileName + ".v");

    /* Open output file for writing */
    QFile outputFile(outputFilePath);
    if (!outputFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qCritical() << "Error: Failed to open output file for writing:" << outputFilePath;
        return false;
    }

    QTextStream out(&outputFile);

    /* Generate file header */
    out << "/**\n";
    out << " * @file " << outputFileName << ".v\n";
    out << " * @brief RTL implementation of " << outputFileName << "\n";
    out << " *\n";
    out << " * @details This file contains RTL implementation based on the input netlist.\n"
        << " *          Auto-generated RTL Verilog file. Generated by "
        << QCoreApplication::applicationName() << " " << QCoreApplication::applicationVersion()
        << ".\n";
    out << " * NOTE: Auto-generated file, do not edit manually.\n";
    out << " */\n\n";

    out << "`timescale 1ns / 1ps\n\n";

    /* Generate reset primitive controllers first (before top-level module) */
    if (netlistData["reset"] && netlistData["reset"].IsSequence()
        && netlistData["reset"].size() > 0) {
        for (size_t i = 0; i < netlistData["reset"].size(); ++i) {
            const YAML::Node &resetItem = netlistData["reset"][i];

            if (!resetItem.IsMap()) {
                qWarning() << "Skipping invalid reset item at index" << i;
                continue;
            }

            if (!generateResetPrimitive(resetItem, out)) {
                qWarning() << "Failed to generate reset primitive at index" << i;
                continue;
            }

            /* Add blank line between different reset blocks */
            if (i < netlistData["reset"].size() - 1) {
                out << "\n";
            }
        }
    }

    /* Generate clock primitive controllers second (before top-level module) */
    if (netlistData["clock"] && netlistData["clock"].IsSequence()
        && netlistData["clock"].size() > 0) {
        for (size_t i = 0; i < netlistData["clock"].size(); ++i) {
            const YAML::Node &clockItem = netlistData["clock"][i];

            if (!clockItem.IsMap()) {
                qWarning() << "Skipping invalid clock item at index" << i;
                continue;
            }

            if (!generateClockPrimitive(clockItem, out)) {
                qWarning() << "Failed to generate clock primitive at index" << i;
                continue;
            }

            /* Add blank line between different clock blocks */
            if (i < netlistData["clock"].size() - 1) {
                out << "\n";
            }
        }
    }

    /* Generate FSM primitive controllers third (before top-level module) */
    if (netlistData["fsm"] && netlistData["fsm"].IsSequence() && netlistData["fsm"].size() > 0) {
        for (size_t i = 0; i < netlistData["fsm"].size(); ++i) {
            const YAML::Node &fsmItem = netlistData["fsm"][i];

            if (!fsmItem.IsMap() || !fsmItem["name"] || !fsmItem["name"].IsScalar()
                || !fsmItem["clk"] || !fsmItem["clk"].IsScalar() || !fsmItem["rst"]
                || !fsmItem["rst"].IsScalar() || !fsmItem["rst_state"]
                || !fsmItem["rst_state"].IsScalar()) {
                qWarning() << "Warning: FSM" << i << "has invalid format, skipping";
                continue; /* Skip invalid FSM items */
            }

            if (!generateFSMPrimitive(fsmItem, out)) {
                qWarning() << "Failed to generate FSM primitive at index" << i;
                continue;
            }

            /* Add blank line between different FSM blocks */
            if (i < netlistData["fsm"].size() - 1) {
                out << "\n";
            }
        }
    }

    /* Check if we need to generate a top-level module */
    bool hasPorts = netlistData["port"] && netlistData["port"].IsMap()
                    && netlistData["port"].size() > 0;
    bool hasNets = netlistData["net"] && netlistData["net"].IsMap()
                   && netlistData["net"].size() > 0;
    bool hasBus = netlistData["bus"] && netlistData["bus"].IsMap() && netlistData["bus"].size() > 0;

    bool needsTopLevelModule = hasInstances || hasPorts || hasNets || hasBus;

    if (!needsTopLevelModule) {
        /* No top-level module needed */
        if (hasCombSeqFsm) {
            /* If only comb/seq exist, generate a wrapper module for them */
            out << "module " << outputFileName << " ();\n\n";

            /* Generate combinational logic */
            if (!generateCombPrimitive(netlistData, out)) {
                qWarning() << "Failed to generate combinational logic primitives";
                return false;
            }

            /* Generate sequential logic */
            if (!generateSeqPrimitive(netlistData, out)) {
                qWarning() << "Failed to generate sequential logic primitives";
                return false;
            }

            out << "\nendmodule\n";
        }

        outputFile.close();
        qInfo() << "Successfully generated Verilog file:" << outputFilePath;
        formatVerilogFile(outputFilePath);
        return true;
    }

    /* Generate top-level module declaration */
    out << "module " << outputFileName;

    /* Add module parameters if they exist */
    if (netlistData["parameter"] && netlistData["parameter"].IsMap()
        && netlistData["parameter"].size() > 0) {
        out << " #(\n";
        QStringList paramDeclarations;

        for (auto paramIter = netlistData["parameter"].begin();
             paramIter != netlistData["parameter"].end();
             ++paramIter) {
            if (!paramIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid parameter name, skipping";
                continue;
            }

            const QString paramName = QString::fromStdString(paramIter->first.as<std::string>());

            if (!paramIter->second.IsMap()) {
                qWarning() << "Warning: Parameter" << paramName << "has invalid format, skipping";
                continue;
            }

            /* Default to empty for Verilog 2001 */
            QString paramType  = "";
            QString paramValue = "";

            if (paramIter->second["type"] && paramIter->second["type"].IsScalar()) {
                paramType = QString::fromStdString(paramIter->second["type"].as<std::string>());
                /* Clean type for Verilog 2001 compatibility */
                paramType = QSocGenerateManager::cleanTypeForWireDeclaration(paramType);

                /* Add a space if type isn't empty after processing */
                if (!paramType.isEmpty() && !paramType.endsWith(" ")) {
                    paramType += " ";
                }
            }

            if (paramIter->second["value"] && paramIter->second["value"].IsScalar()) {
                paramValue = QString::fromStdString(paramIter->second["value"].as<std::string>());
            }

            paramDeclarations.append(
                QString("    parameter %1%2 = %3").arg(paramType).arg(paramName).arg(paramValue));
        }

        if (!paramDeclarations.isEmpty()) {
            out << paramDeclarations.join(",\n") << "\n";
        }
        out << ")";
    }

    /* Start port list */
    out << " (";

    /* Collect all ports for module interface */
    QStringList            ports;
    QMap<QString, QString> portToNetConnections; /* Map of port name to connected net name */

    /* Process port section if it exists */
    if (netlistData["port"] && netlistData["port"].IsMap()) {
        for (auto portIter = netlistData["port"].begin(); portIter != netlistData["port"].end();
             ++portIter) {
            if (!portIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid port name, skipping";
                continue;
            }

            const QString portName = QString::fromStdString(portIter->first.as<std::string>());

            if (!portIter->second.IsMap()) {
                qWarning() << "Warning: Port" << portName << "has invalid format, skipping";
                continue;
            }

            QString direction = "input";
            QString type      = ""; /* Empty type by default for Verilog 2001 */

            if (portIter->second["direction"] && portIter->second["direction"].IsScalar()) {
                const QString dirStr = QString::fromStdString(
                                           portIter->second["direction"].as<std::string>())
                                           .toLower();

                /* Handle both full and abbreviated forms */
                if (dirStr == "out" || dirStr == "output") {
                    direction = "output";
                } else if (dirStr == "in" || dirStr == "input") {
                    direction = "input";
                } else if (dirStr == "inout") {
                    direction = "inout";
                }
            }

            /* Get port type/width information if present */
            if (portIter->second["type"] && portIter->second["type"].IsScalar()) {
                type = QString::fromStdString(portIter->second["type"].as<std::string>());
                /* Clean type for Verilog 2001 compatibility */
                type = QSocGenerateManager::cleanTypeForWireDeclaration(type);
            }

            /* Store the connection information if present */
            if (portIter->second["connect"] && portIter->second["connect"].IsScalar()) {
                const QString connectedNet = QString::fromStdString(
                    portIter->second["connect"].as<std::string>());
                portToNetConnections[portName] = connectedNet;
            }

            /* Add port declaration */
            ports.append(QString("%1 %2").arg(direction).arg(
                type.isEmpty() ? portName : type + " " + portName));
        }
    }

    /* Close module declaration */
    if (!ports.isEmpty()) {
        /* If we have parameters, add a comma after them */
        out << "\n    " << ports.join(",\n    ") << "\n";
    }
    out << ");\n\n";

    /* Build a mapping of all connections for each instance and port */
    QMap<QString, QMap<QString, QString>> instancePortConnections;

    /* First, create the instancePortConnections map with port connections */
    /* This needs to be done before wire generation to ensure port names are used */
    if (netlistData["net"] && netlistData["net"].IsMap()) {
        for (auto netIter = netlistData["net"].begin(); netIter != netlistData["net"].end();
             ++netIter) {
            if (!netIter->first.IsScalar()) {
                continue;
            }

            const QString netName = QString::fromStdString(netIter->first.as<std::string>());

            /* Check if this net is connected to a top-level port */
            QString connectedPortName;
            bool    connectedToTopPort = false;

            for (auto it = portToNetConnections.begin(); it != portToNetConnections.end(); ++it) {
                if (it.value() == netName) {
                    connectedToTopPort = true;
                    connectedPortName  = it.key();
                    break;
                }
            }

            try {
                /* Build connections using List format only */
                const YAML::Node &netNode = netIter->second;
                if (netNode.IsSequence()) {
                    /* Process List format connections */
                    for (const auto &connectionNode : netNode) {
                        if (!connectionNode.IsMap()) {
                            qWarning() << "Warning: Invalid connection node in net" << netName;
                            continue;
                        }

                        /* Get instance name */
                        if (!connectionNode["instance"] || !connectionNode["instance"].IsScalar()) {
                            qWarning()
                                << "Warning: No instance name in connection for net" << netName;
                            continue;
                        }
                        const QString instanceName = QString::fromStdString(
                            connectionNode["instance"].as<std::string>());

                        /* Get port name */
                        if (!connectionNode["port"] || !connectionNode["port"].IsScalar()) {
                            qWarning() << "Warning: No port name in connection for net" << netName;
                            continue;
                        }
                        const QString portName = QString::fromStdString(
                            connectionNode["port"].as<std::string>());

                        /* If this is a top-level port connection, add it to portToNetConnections */
                        if (instanceName == "top") {
                            portToNetConnections[portName] = netName;
                        }

                        /* Check if this port has invert attribute */
                        bool hasInvert = false;
                        if (netlistData["instance"]
                            && netlistData["instance"][instanceName.toStdString()]
                            && netlistData["instance"][instanceName.toStdString()]["port"]
                            && netlistData["instance"][instanceName.toStdString()]["port"]
                                          [portName.toStdString()]) {
                            auto portNode = netlistData["instance"][instanceName.toStdString()]
                                                       ["port"][portName.toStdString()];
                            if (portNode.IsMap() && portNode["invert"]
                                && portNode["invert"].IsScalar()) {
                                /* Use direct YAML boolean parsing */
                                if (portNode["invert"].as<bool>()) {
                                    hasInvert = true;
                                }
                            }
                        }

                        /* Check if this port has bits selection attribute */
                        QString bitSelect = "";
                        if (connectionNode["bits"] && connectionNode["bits"].IsScalar()) {
                            bitSelect = QString::fromStdString(
                                connectionNode["bits"].as<std::string>());
                        }

                        /* If connected to top-level port, use the port name instead of net name */
                        if (connectedToTopPort) {
                            instancePortConnections[instanceName][portName]
                                = hasInvert ? QString("~%1%2")
                                                  .arg(connectedPortName)
                                                  .arg(bitSelect.isEmpty() ? "" : bitSelect)
                                            : QString("%1%2")
                                                  .arg(connectedPortName)
                                                  .arg(bitSelect.isEmpty() ? "" : bitSelect);
                        } else {
                            instancePortConnections[instanceName][portName]
                                = hasInvert ? QString("~%1%2").arg(netName).arg(
                                                  bitSelect.isEmpty() ? "" : bitSelect)
                                            : QString("%1%2").arg(netName).arg(
                                                  bitSelect.isEmpty() ? "" : bitSelect);
                        }
                    }
                } else {
                    qWarning() << "Warning: Net" << netName
                               << "is not in List format, skipping connections";
                }
            } catch (const std::exception &e) {
                qWarning() << "Error processing net:" << e.what();
            }
        }
    }

    /* Add connections (wires) section comment */
    out << "    /* Wire declarations */\n";

    /* Generate wire declarations FIRST */
    if (netlistData["net"]) {
        if (!netlistData["net"].IsMap()) {
            qWarning() << "Warning: 'net' section is not a map, skipping wire declarations";
        } else if (netlistData["net"].size() == 0) {
            qWarning() << "Warning: 'net' section is empty, no wire declarations to generate";
        } else {
            for (auto netIter = netlistData["net"].begin(); netIter != netlistData["net"].end();
                 ++netIter) {
                if (!netIter->first.IsScalar()) {
                    qWarning() << "Warning: Invalid net name, skipping";
                    continue;
                }

                const QString netName = QString::fromStdString(netIter->first.as<std::string>());

                if (!netIter->second) {
                    qWarning() << "Warning: Net" << netName << "has null data, skipping";
                    continue;
                }

                /* Net connections should be a sequence (list) of instance-port pairs */
                if (!netIter->second.IsSequence()) {
                    qWarning() << "Warning: Net" << netName << "is not a sequence, skipping";
                    continue;
                }

                const YAML::Node &connections = netIter->second;

                if (connections.size() == 0) {
                    qWarning() << "Warning: Net" << netName << "has no connections, skipping";
                    continue;
                }

                /* Build a list of instance-port pairs for width check */
                QList<PortConnection> portConnections;
                /* Collect detailed port information for each connection */
                QList<PortDetailInfo> portDetails;

                /* Check if this net is connected to a top-level port */
                bool    connectedToTopPort = false;
                QString connectedPortName;
                QString topLevelPortDirection = "unknown";
                QString reversedDirection = "unknown"; /* Default fallback, defined in outer scope */

                /* Check if this net is connected to a top-level port */
                for (auto it = portToNetConnections.begin(); it != portToNetConnections.end();
                     ++it) {
                    if (it.value() == netName) {
                        connectedToTopPort = true;
                        connectedPortName  = it.key();

                        /* Get the port direction */
                        if (netlistData["port"]
                            && netlistData["port"][connectedPortName.toStdString()]
                            && netlistData["port"][connectedPortName.toStdString()]["direction"]
                            && netlistData["port"][connectedPortName.toStdString()]["direction"]
                                   .IsScalar()) {
                            const QString dirStr
                                = QString::fromStdString(
                                      netlistData["port"][connectedPortName.toStdString()]
                                                 ["direction"]
                                                     .as<std::string>())
                                      .toLower();

                            /* Store original direction for later use */
                            if (dirStr == "out" || dirStr == "output") {
                                topLevelPortDirection = "output";
                            } else if (dirStr == "in" || dirStr == "input") {
                                topLevelPortDirection = "input";
                            } else if (dirStr == "inout") {
                                topLevelPortDirection = "inout";
                            }

                            /* Reverse the direction for internal checking */
                            if (topLevelPortDirection == "output") {
                                reversedDirection
                                    = "input"; /* Top-level output is an input for internal nets */
                            } else if (topLevelPortDirection == "input") {
                                reversedDirection
                                    = "output"; /* Top-level input is an output for internal nets */
                            } else if (topLevelPortDirection == "inout") {
                                reversedDirection = "inout"; /* Bidirectional remains bidirectional */
                            }
                        }

                        /* Add top-level port to connection list */
                        portConnections.append(
                            PortConnection::createTopLevelPort(connectedPortName));

                        /* Get port width */
                        QString portWidthSpec = "";

                        /* Get port width/type from the same node we used for direction */
                        if (netlistData["port"]
                            && netlistData["port"][connectedPortName.toStdString()]) {
                            auto portNode = netlistData["port"][connectedPortName.toStdString()];

                            /* Get port width/type */
                            if (portNode["type"] && portNode["type"].IsScalar()) {
                                portWidthSpec = QString::fromStdString(
                                    portNode["type"].as<std::string>());
                            }
                        }

                        /* Initialize bitSelection as empty string */
                        const QString bitSelection = "";

                        /* CRITICAL FIX: Top-level port direction internal/external viewpoint
                         *
                         * Top-level OUTPUT port:
                         *   - External viewpoint: outputs signal to outside world
                         *   - Internal viewpoint: receives signal from internal logic (acts as INPUT)
                         *   - Internal module OUTPUT drives top-level OUTPUT = VALID (not multidriven)
                         *
                         * Top-level INPUT port:
                         *   - External viewpoint: receives signal from outside world
                         *   - Internal viewpoint: provides signal to internal logic (acts as OUTPUT)
                         *   - Internal module INPUT connects to top-level INPUT = VALID (not undriven)
                         *
                         * Store ORIGINAL direction here - checkPortDirectionConsistencyWithBitOverlap
                         * will handle the internal/external direction conversion uniformly.
                         */
                        /* Add to detailed port information with original direction */
                        portDetails.append(
                            PortDetailInfo::createTopLevelPort(
                                connectedPortName,
                                portWidthSpec,
                                topLevelPortDirection,
                                bitSelection));
                        break;
                    }
                }

                /* Build port connections from netlistData */
                const YAML::Node &netNode = netlistData["net"][netName.toStdString()];
                if (netNode.IsSequence()) {
                    for (const auto &connectionNode : netNode) {
                        if (!connectionNode.IsMap()) {
                            qWarning() << "Warning: Invalid connection node in net" << netName;
                            continue;
                        }

                        /* Get instance name */
                        if (!connectionNode["instance"] || !connectionNode["instance"].IsScalar()) {
                            qWarning()
                                << "Warning: No instance name in connection for net" << netName;
                            continue;
                        }
                        const QString instanceName = QString::fromStdString(
                            connectionNode["instance"].as<std::string>());

                        /* Get port name */
                        if (!connectionNode["port"] || !connectionNode["port"].IsScalar()) {
                            qWarning() << "Warning: No port name in connection for net" << netName;
                            continue;
                        }
                        const QString portName = QString::fromStdString(
                            connectionNode["port"].as<std::string>());

                        /* If this is a top-level port connection, add it to portToNetConnections */
                        if (instanceName == "top") {
                            portToNetConnections[portName] = netName;
                        }

                        /* Create a module port connection */
                        portConnections.append(
                            PortConnection::createModulePort(instanceName, portName));

                        /* Get additional details for this port */
                        QString portWidthSpec = "";
                        QString portDirection = "unknown";

                        /* Check if this connection has preserved type information from bus expansion */
                        if (connectionNode["type"] && connectionNode["type"].IsScalar()) {
                            portWidthSpec = QString::fromStdString(
                                connectionNode["type"].as<std::string>());
                        }

                        /* Check if this port has bits selection attribute */
                        QString bitSelection = "";
                        if (connectionNode["bits"] && connectionNode["bits"].IsScalar()) {
                            bitSelection = QString::fromStdString(
                                connectionNode["bits"].as<std::string>());
                        }

                        /* Get instance's module */
                        if (netlistData["instance"][instanceName.toStdString()]
                            && netlistData["instance"][instanceName.toStdString()]["module"]
                            && netlistData["instance"][instanceName.toStdString()]["module"]
                                   .IsScalar()) {
                            const QString moduleName = QString::fromStdString(
                                netlistData["instance"][instanceName.toStdString()]["module"]
                                    .as<std::string>());

                            /* Get module definition */
                            if (moduleManager && moduleManager->isModuleExist(moduleName)) {
                                YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);

                                if (moduleData["port"] && moduleData["port"].IsMap()
                                    && moduleData["port"][portName.toStdString()]) {
                                    /* Get port width only if not already preserved from bus expansion */
                                    if (portWidthSpec.isEmpty()
                                        && moduleData["port"][portName.toStdString()]["type"]
                                        && moduleData["port"][portName.toStdString()]["type"]
                                               .IsScalar()) {
                                        const QString originalType = QString::fromStdString(
                                            moduleData["port"][portName.toStdString()]["type"]
                                                .as<std::string>());
                                        /* Keep original type for width calculation, but clean for display */
                                        portWidthSpec = originalType;
                                    }

                                    /* Get port direction */
                                    if (moduleData["port"][portName.toStdString()]["direction"]
                                        && moduleData["port"][portName.toStdString()]["direction"]
                                               .IsScalar()) {
                                        portDirection = QString::fromStdString(
                                            moduleData["port"][portName.toStdString()]["direction"]
                                                .as<std::string>());
                                        /* Handle both full and abbreviated forms */
                                        if (portDirection == "out" || portDirection == "output") {
                                            portDirection = "output";
                                        } else if (portDirection == "in" || portDirection == "input") {
                                            portDirection = "input";
                                        } else if (portDirection == "inout") {
                                            portDirection = "inout";
                                        }
                                    }
                                }
                            }
                        }

                        /* Add to detailed port information */
                        portDetails.append(
                            PortDetailInfo::createModulePort(
                                instanceName, portName, portWidthSpec, portDirection, bitSelection));
                    }
                }

                /* Add comb/seq/fsm outputs as additional drivers for this net */
                QList<PortDetailInfo> combSeqFsmOutputs = collectCombSeqFsmOutputs();
                for (const PortDetailInfo &combOutput : combSeqFsmOutputs) {
                    // Check if this comb/seq/fsm output drives the current net
                    QString outputBaseName  = combOutput.portName;
                    QString outputBitSelect = combOutput.bitSelect;

                    // If output has bit selection, it affects only part of the signal
                    // If no bit selection, it affects the full signal
                    bool drivesThisNet = false;

                    if (outputBaseName == netName) {
                        drivesThisNet = true;
                    } else if (connectedToTopPort && outputBaseName == connectedPortName) {
                        drivesThisNet = true;
                    }

                    if (drivesThisNet) {
                        // Add this comb/seq/fsm output as a driver
                        // Include bit selection in the port name if it exists
                        QString fullSignalName = outputBaseName;
                        if (!outputBitSelect.isEmpty()) {
                            fullSignalName = outputBaseName + outputBitSelect;
                        }
                        portConnections.append(PortConnection::createCombSeqFsmPort(fullSignalName));

                        portDetails.append(
                            PortDetailInfo::createCombSeqFsmPort(
                                outputBaseName,
                                combOutput.width,
                                "output", // comb/seq/fsm outputs are always output drivers
                                outputBitSelect));
                    }
                }

                /* Check port width consistency */
                const bool hasWidthMismatch = !checkPortWidthConsistency(portConnections);
                if (hasWidthMismatch) {
                    qWarning() << "Warning: Port width mismatch detected for net" << netName;
                }

                /* Check port direction consistency with bit-level overlap detection */
                const PortDirectionStatus dirStatus = checkPortDirectionConsistencyWithBitOverlap(
                    portDetails);
                const bool isUndriven   = (dirStatus == PortDirectionStatus::Undriven);
                const bool isMultidrive = (dirStatus == PortDirectionStatus::Multidrive);

                if (isUndriven) {
                    qWarning() << "Warning: Net" << netName
                               << "has only input ports, missing driver";
                } else if (isMultidrive) {
                    qWarning() << "Warning: Net" << netName << "has multiple output/inout ports";
                }

                /* Generate combined warning comments for the net */
                if (hasWidthMismatch || isUndriven || isMultidrive) {
                    /* Output width mismatch warning if detected */
                    if (hasWidthMismatch) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") width mismatch - please check connected ports:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " width mismatch - please check connected ports:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            /* Clean width information for display */
                            QString displayWidth
                                = detail.width.isEmpty()
                                      ? "default"
                                      : QSocGenerateManager::cleanTypeForWireDeclaration(
                                            detail.width);
                            if (displayWidth.isEmpty() && !detail.width.isEmpty()) {
                                displayWidth
                                    = "default"; /* fallback for single-bit types like "logic" */
                            }

                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, display the actual direction used in checking */
                                QString displayDirection = detail.direction;

                                out << "     *   Top-Level Port: " << detail.portName
                                    << ", Direction: " << displayDirection
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else if (detail.type == PortType::CombSeqFsm) {
                                /* Comb/Seq/FSM output */
                                out << "     *   Comb/Seq/FSM Output: " << detail.portName
                                    << ", Direction: " << detail.direction
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }

                    /* Output undriven warning if detected */
                    if (isUndriven) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") is undriven - missing source:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " is undriven - missing source:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            /* Clean width information for display */
                            QString displayWidth
                                = detail.width.isEmpty()
                                      ? "default"
                                      : QSocGenerateManager::cleanTypeForWireDeclaration(
                                            detail.width);
                            if (displayWidth.isEmpty() && !detail.width.isEmpty()) {
                                displayWidth
                                    = "default"; /* fallback for single-bit types like "logic" */
                            }

                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, display the actual direction used in checking */
                                QString displayDirection = detail.direction;

                                out << "     *   Top-Level Port: " << detail.portName
                                    << ", Direction: " << displayDirection
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }

                    /* Output multidrive warning if detected */
                    if (isMultidrive) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") has multiple drivers - potential conflict:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " has multiple drivers - potential conflict:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            /* Clean width information for display */
                            QString displayWidth
                                = detail.width.isEmpty()
                                      ? "default"
                                      : QSocGenerateManager::cleanTypeForWireDeclaration(
                                            detail.width);
                            if (displayWidth.isEmpty() && !detail.width.isEmpty()) {
                                displayWidth
                                    = "default"; /* fallback for single-bit types like "logic" */
                            }

                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, display the actual direction used in checking */
                                QString displayDirection = detail.direction;

                                out << "     *   Top-Level Port: " << detail.portName
                                    << ", Direction: " << displayDirection
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else if (detail.type == PortType::CombSeqFsm) {
                                /* Comb/Seq/FSM output */
                                out << "     *   Comb/Seq/FSM Output: " << detail.portName
                                    << ", Direction: " << detail.direction
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }
                }

                /* Only declare wire if not connected to top-level port to avoid redundancy */
                if (!connectedToTopPort) {
                    /* Get net width from all ports connected to this net */
                    QString netWidth = "";
                    int     maxWidth = 0;

                    /* First check if any connection has preserved type information with range format */
                    QString preservedRangeType = "";
                    for (const auto &detail : portDetails) {
                        if (!detail.width.isEmpty()) {
                            /* Check if this looks like a preserved range type [X:Y] format */
                            const QRegularExpression rangeRegex(
                                R"(logic\s*\[\s*(\d+)\s*:\s*(\d+)\s*\])");
                            const QRegularExpressionMatch rangeMatch = rangeRegex.match(
                                detail.width);
                            if (rangeMatch.hasMatch()) {
                                /* Found preserved range type - use it directly */
                                preservedRangeType = detail.width;
                                break;
                            }
                        }
                    }

                    /* If we found preserved range type, use it directly */
                    if (!preservedRangeType.isEmpty()) {
                        netWidth = preservedRangeType;
                    } else {
                        /* Find the maximum bit index needed for this net based on port widths */
                        int maxBitIndex = -1;

                        for (const auto &detail : portDetails) {
                            int requiredMaxBit = -1;

                            /* Always check the port's original width first */
                            if (!detail.width.isEmpty()) {
                                /* Check if it's a single bit type (logic, wire) */
                                if (detail.width == "logic" || detail.width == "wire") {
                                    /* Single bit port - wire should be single bit regardless of bit selection */
                                    requiredMaxBit = 0;
                                } else {
                                    /* Attempt to extract width value from format like [31:0] or [7] */
                                    const QRegularExpression widthRegex(
                                        R"(\[\s*(\d+)\s*(?::\s*(\d+))?\s*\])");
                                    const QRegularExpressionMatch match = widthRegex.match(
                                        detail.width);
                                    if (match.hasMatch()) {
                                        bool      msb_ok = false;
                                        const int msb    = match.captured(1).toInt(&msb_ok);

                                        if (msb_ok) {
                                            requiredMaxBit = msb;
                                        }
                                    }
                                }
                            }

                            /* If no port width found, fall back to bit selection */
                            /* Note: This fallback should only be used when port width is unknown */
                            if (requiredMaxBit == -1 && !detail.bitSelect.isEmpty()) {
                                /* Parse bit selection like [7:4], [3:0], or [5] */
                                const QRegularExpression bitSelectRegex(
                                    R"(\[\s*(\d+)\s*(?::\s*(\d+))?\s*\])");
                                const QRegularExpressionMatch bitMatch = bitSelectRegex.match(
                                    detail.bitSelect);
                                if (bitMatch.hasMatch()) {
                                    bool      msb_ok = false;
                                    const int msb    = bitMatch.captured(1).toInt(&msb_ok);
                                    if (msb_ok) {
                                        if (bitMatch.capturedLength(2) > 0) {
                                            /* Range selection like [7:4] - we need up to MSB */
                                            requiredMaxBit = msb;
                                        } else {
                                            /* Single bit selection like [5] - we need up to that bit */
                                            requiredMaxBit = msb;
                                        }
                                    }
                                }
                            }

                            /* Update the maximum bit index needed */
                            if (requiredMaxBit > maxBitIndex) {
                                maxBitIndex = requiredMaxBit;
                            }
                        }

                        /* Generate the net width specification */
                        if (maxBitIndex >= 0) {
                            if (maxBitIndex == 0) {
                                /* Single bit, no range needed */
                                netWidth = "";
                            } else {
                                /* Multi-bit, generate [msb:0] format */
                                netWidth = QString("[%1:0]").arg(maxBitIndex);
                            }
                            maxWidth = maxBitIndex + 1;
                        }
                    }

                    /* If no width found from ports, try from net type as fallback */
                    if (netWidth.isEmpty() && netlistData["net"]
                        && netlistData["net"][netName.toStdString()]
                        && netlistData["net"][netName.toStdString()]["type"]
                        && netlistData["net"][netName.toStdString()]["type"].IsScalar()) {
                        netWidth = QString::fromStdString(
                            netlistData["net"][netName.toStdString()]["type"].as<std::string>());
                    }

                    /* Add wire declaration for this net with width information if available */
                    if (!netWidth.isEmpty()) {
                        /* Clean the type string to remove unwanted keywords like 'reg', 'logic', etc. */
                        const QString cleanedWidth
                            = QSocGenerateManager::cleanTypeForWireDeclaration(netWidth);
                        if (!cleanedWidth.isEmpty()) {
                            out << "    wire " << cleanedWidth << " " << netName << ";\n";
                        } else {
                            out << "    wire " << netName << ";\n";
                        }
                    } else {
                        out << "    wire " << netName << ";\n";
                    }
                } else {
                    /* Check for width mismatches between port and net */
                    QString portWidth     = "";
                    QString netWidth      = "";
                    QString portDirection = "input";

                    /* Get port information */
                    if (netlistData["port"]
                        && netlistData["port"][connectedPortName.toStdString()]) {
                        auto portNode = netlistData["port"][connectedPortName.toStdString()];

                        /* Get port direction */
                        if (portNode["direction"] && portNode["direction"].IsScalar()) {
                            const QString dirStr = QString::fromStdString(
                                                       portNode["direction"].as<std::string>())
                                                       .toLower();

                            /* Handle both full and abbreviated forms */
                            if (dirStr == "out" || dirStr == "output") {
                                portDirection = "output";
                            } else if (dirStr == "in" || dirStr == "input") {
                                portDirection = "input";
                            } else if (dirStr == "inout") {
                                portDirection = "inout";
                            }
                        }

                        /* Get port width/type */
                        if (portNode["type"] && portNode["type"].IsScalar()) {
                            portWidth = QString::fromStdString(portNode["type"].as<std::string>());
                        }
                    }

                    /* Get net width */
                    if (netlistData["net"] && netlistData["net"][netName.toStdString()]
                        && netlistData["net"][netName.toStdString()]["type"]
                        && netlistData["net"][netName.toStdString()]["type"].IsScalar()) {
                        netWidth = QString::fromStdString(
                            netlistData["net"][netName.toStdString()]["type"].as<std::string>());
                    }

                    /* Check width compatibility */
                    const bool widthMismatch = !portWidth.isEmpty() && !netWidth.isEmpty()
                                               && portWidth != netWidth;

                    /* Add width mismatch FIXME comment if needed */
                    if (widthMismatch) {
                        out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                            << ") width mismatch - port width: " << portWidth
                            << ", net width: " << netWidth << " */\n";
                    }

                    /* Note: Removed inout bidirectional behavior warning - this is normal for uplink connections */
                }
            }
            out << "\n";
        }
    } else {
        qWarning()
            << "Warning: No 'net' section in netlist, no wire declarations will be generated";
    }

    /* Add instances section comment */
    out << "    /* Module instantiations */\n";

    /* Generate instance declarations after wire declarations */
    if (netlistData["instance"] && netlistData["instance"].IsMap()) {
        for (auto instanceIter = netlistData["instance"].begin();
             instanceIter != netlistData["instance"].end();
             ++instanceIter) {
            /* Check if the instance name is a scalar */
            if (!instanceIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid instance name, skipping";
                continue;
            }

            const QString instanceName = QString::fromStdString(
                instanceIter->first.as<std::string>());

            /* Check if the instance data is valid */
            if (!instanceIter->second || !instanceIter->second.IsMap()) {
                qWarning() << "Warning: Invalid instance data for" << instanceName
                           << "(not a map), skipping";
                continue;
            }

            const YAML::Node &instanceData = instanceIter->second;

            if (!instanceData["module"] || !instanceData["module"].IsScalar()) {
                qWarning() << "Warning: Invalid module name for instance" << instanceName;
                continue;
            }

            const QString moduleName = QString::fromStdString(
                instanceData["module"].as<std::string>());

            /* Generate instance declaration with parameters if any */
            out << "    " << moduleName << " ";

            /* Add parameters if they exist */
            if (instanceData["parameter"]) {
                if (!instanceData["parameter"].IsMap()) {
                    qWarning() << "Warning: 'parameter' section for instance" << instanceName
                               << "is not a map, ignoring";
                } else if (instanceData["parameter"].size() == 0) {
                    qWarning() << "Warning: 'parameter' section for instance" << instanceName
                               << "is empty, ignoring";
                } else {
                    out << "#(\n";

                    QStringList paramList;
                    for (auto paramIter = instanceData["parameter"].begin();
                         paramIter != instanceData["parameter"].end();
                         ++paramIter) {
                        if (!paramIter->first.IsScalar()) {
                            qWarning()
                                << "Warning: Invalid parameter name in instance" << instanceName;
                            continue;
                        }

                        if (!paramIter->second.IsScalar()) {
                            qWarning() << "Warning: Parameter"
                                       << QString::fromStdString(paramIter->first.as<std::string>())
                                       << "in instance" << instanceName
                                       << "has a non-scalar value, skipping";
                            continue;
                        }

                        const QString paramName = QString::fromStdString(
                            paramIter->first.as<std::string>());
                        const QString paramValue = QString::fromStdString(
                            paramIter->second.as<std::string>());

                        paramList.append(QString("        .%1(%2)").arg(paramName).arg(paramValue));
                    }

                    out << paramList.join(",\n") << "\n    ) ";
                }
            }

            out << instanceName << " (\n";

            /* Get the port connections for this instance */
            QStringList portConnections;

            /* Get module definition to ensure all ports are listed */
            if (moduleManager && moduleManager->isModuleExist(moduleName)) {
                YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);

                if (moduleData["port"] && moduleData["port"].IsMap()) {
                    /* Get the existing connections map for this instance */
                    QMap<QString, QString> portMap;
                    if (instancePortConnections.contains(instanceName)) {
                        portMap = instancePortConnections[instanceName];
                    }

                    /* Iterate through all ports in the module definition */
                    for (auto portIter = moduleData["port"].begin();
                         portIter != moduleData["port"].end();
                         ++portIter) {
                        if (!portIter->first.IsScalar()) {
                            qWarning() << "Warning: Invalid port name in module" << moduleName;
                            continue;
                        }

                        const QString portName = QString::fromStdString(
                            portIter->first.as<std::string>());

                        /* Check if this port has a connection */
                        if (portMap.contains(portName)) {
                            const QString wireConnection = portMap[portName];
                            portConnections.append(
                                QString("        .%1(%2)").arg(portName).arg(wireConnection));
                        } else {
                            /* Port exists in module but has no connection */
                            QString direction = "signal";
                            QString width     = "";

                            if (portIter->second && portIter->second["direction"]
                                && portIter->second["direction"].IsScalar()) {
                                direction = QString::fromStdString(
                                    portIter->second["direction"].as<std::string>());
                            }

                            /* Get port width/type */
                            if (portIter->second && portIter->second["type"]
                                && portIter->second["type"].IsScalar()) {
                                QString type = QString::fromStdString(
                                    portIter->second["type"].as<std::string>());

                                /* Clean type for Verilog 2001 compatibility */
                                type = QSocGenerateManager::cleanTypeForWireDeclaration(type);

                                /* Extract width information if it exists in format [x:y] or [x] */
                                const QRegularExpression widthRegex(
                                    R"(\[\s*(\d+)\s*(?::\s*(\d+))?\s*\])");
                                const QRegularExpressionMatch match = widthRegex.match(type);
                                if (match.hasMatch()) {
                                    /* Both [x] and [x:y] formats use the full match */
                                    width = match.captured(0);
                                }
                            }

                            /* Check for tie attribute in instance's port */
                            bool    hasTie = false;
                            QString tieValue;
                            int     portWidth = 1; /* Default width if not specified */

                            /* Extract port width for bit size validation */
                            if (!width.isEmpty()) {
                                const QRegularExpression widthRegex(R"(\[(\d+)(?::(\d+))?\])");
                                auto                     match = widthRegex.match(width);
                                if (match.hasMatch()) {
                                    bool      msb_ok = false;
                                    const int msb    = match.captured(1).toInt(&msb_ok);
                                    if (msb_ok) {
                                        if (match.capturedLength(2) > 0) {
                                            /* Case with specified LSB, e.g. [7:3] */
                                            bool      lsb_ok = false;
                                            const int lsb    = match.captured(2).toInt(&lsb_ok);
                                            if (lsb_ok) {
                                                portWidth = qAbs(msb - lsb) + 1;
                                            } else {
                                                portWidth = msb
                                                            + 1; /* Fallback to default handling */
                                            }
                                        } else {
                                            /* Case with only MSB specified, e.g. [7] */
                                            portWidth = msb + 1; /* [7] means 8 bits [7:0] */
                                        }
                                    }
                                }
                            }

                            /* Check if this port is already connected to any net in the design */
                            bool isConnectedToNet = false;
                            if (netlistData["net"] && netlistData["net"].IsMap()) {
                                for (auto netIter = netlistData["net"].begin();
                                     netIter != netlistData["net"].end() && !isConnectedToNet;
                                     ++netIter) {
                                    if (netIter->second.IsSequence()) {
                                        for (const auto &connectionNode : netIter->second) {
                                            if (connectionNode.IsMap() && connectionNode["instance"]
                                                && connectionNode["instance"].IsScalar()
                                                && connectionNode["port"]
                                                && connectionNode["port"].IsScalar()) {
                                                const QString connectedInstance
                                                    = QString::fromStdString(
                                                        connectionNode["instance"].as<std::string>());
                                                const QString connectedPort = QString::fromStdString(
                                                    connectionNode["port"].as<std::string>());

                                                if (connectedInstance == instanceName
                                                    && connectedPort == portName) {
                                                    isConnectedToNet = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            /* Only proceed with tie if port is not connected to a net */
                            if (!isConnectedToNet) {
                                /* Check if instance has tie attribute for this port */
                                if (netlistData["instance"]
                                    && netlistData["instance"][instanceName.toStdString()]
                                    && netlistData["instance"][instanceName.toStdString()]["port"]
                                    && netlistData["instance"][instanceName.toStdString()]["port"]
                                                  [portName.toStdString()]) {
                                    auto portNode
                                        = netlistData["instance"][instanceName.toStdString()]
                                                     ["port"][portName.toStdString()];

                                    /* Check for tie attribute (only if portNode is a map) */
                                    if (portNode.IsMap() && portNode["tie"]
                                        && portNode["tie"].IsScalar()) {
                                        const QString tieStr = QString::fromStdString(
                                            portNode["tie"].as<std::string>());

                                        /* Parse the tie value using our number parser */
                                        const QSocNumberInfo numInfo = QSocNumberInfo::parseNumber(
                                            tieStr);

                                        /* Only apply tie to input ports */
                                        if (direction.toLower() == "input"
                                            || direction.toLower() == "in") {
                                            hasTie = true;

                                            /* Format the tie value */
                                            /* Create a copy of numInfo with adjusted width */
                                            QSocNumberInfo adjustedInfo = numInfo;

                                            /* Special handling for overflow detection */
                                            if (numInfo.errorDetected) {
                                                /* For overflow values, keep the original string representation */
                                                if (numInfo.width > portWidth) {
                                                    tieValue
                                                        = QString(
                                                              "%1 /* FIXME: Value width %2 bits "
                                                              "exceeds port width %3 bits */")
                                                              .arg(numInfo.originalString)
                                                              .arg(numInfo.width)
                                                              .arg(portWidth);
                                                } else {
                                                    tieValue = numInfo.originalString;
                                                }
                                            } else {
                                                /* Normal handling for regular values */
                                                adjustedInfo.width            = portWidth;
                                                adjustedInfo.hasExplicitWidth = true;

                                                /* Create a mask for the width */
                                                BigUnsigned mask = BigUnsigned(0);
                                                for (int i = 0; i < portWidth; i++) {
                                                    mask = (mask << 1) + BigUnsigned(1);
                                                }
                                                /* Apply mask to truncate the value */
                                                if (adjustedInfo.value.getSign()
                                                    == BigInteger::negative) {
                                                    /* For negative numbers, apply mask to magnitude and maintain sign */
                                                    const BigUnsigned result
                                                        = adjustedInfo.value.getMagnitude() & mask;
                                                    adjustedInfo.value
                                                        = BigInteger(result, BigInteger::negative);
                                                } else {
                                                    /* For non-negative numbers, just apply the mask */
                                                    adjustedInfo.value = BigInteger(
                                                        adjustedInfo.value.getMagnitude() & mask);
                                                }

                                                if (numInfo.width > portWidth) {
                                                    /* Value is wider than port - show FIXME comment but use proper width */
                                                    tieValue
                                                        = QString(
                                                              "%1 /* FIXME: Value %2 wider than "
                                                              "port width %3 bits */")
                                                              .arg(adjustedInfo.formatVerilog())
                                                              .arg(numInfo.formatVerilog())
                                                              .arg(portWidth);
                                                } else {
                                                    /* Use adjusted formatting with correct width, preserving original base */
                                                    tieValue = adjustedInfo.formatVerilog();
                                                }
                                            }

                                            /* Check for invert attribute */
                                            if (portNode.IsMap() && portNode["invert"]
                                                && portNode["invert"].IsScalar()) {
                                                /* Use direct YAML boolean parsing instead of string conversion */
                                                if (portNode["invert"].as<bool>()) {
                                                    /* If we need to invert, apply logical NOT (~) to the value */
                                                    tieValue = QString("~(%1)").arg(tieValue);
                                                }
                                            }
                                        } else {
                                            /* Add warning for non-input ports with tie */
                                            tieValue
                                                = QString(
                                                      "/* FIXME: 'tie' attribute for %1 port %2 "
                                                      "ignored */")
                                                      .arg(direction.toLower())
                                                      .arg(portName);
                                        }
                                    }
                                    /* If no tie but has invert attribute on an input port, warn about missing tie */
                                    else if (
                                        portNode.IsMap() && portNode["invert"]
                                        && portNode["invert"].IsScalar()
                                        && (direction.toLower() == "input"
                                            || direction.toLower() == "in")) {
                                        tieValue = QString(
                                                       "/* FIXME: 'invert' attribute on %1 port %2 "
                                                       "without 'tie' attribute */")
                                                       .arg(direction.toLower())
                                                       .arg(portName);
                                    }
                                }
                            }

                            /* Format port connection based on connection status and tie attribute */
                            if (hasTie
                                && (direction.toLower() == "input" || direction.toLower() == "in")) {
                                portConnections.append(
                                    QString("        .%1(%2)").arg(portName).arg(tieValue));
                            } else if (
                                isConnectedToNet && instancePortConnections.contains(instanceName)
                                && instancePortConnections[instanceName].contains(portName)) {
                                /* Use connection from instancePortConnections if port is connected to a net */
                                const QString connectionValue
                                    = instancePortConnections[instanceName][portName];
                                portConnections.append(
                                    QString("        .%1(%2)").arg(portName).arg(connectionValue));
                            } else {
                                /* Collect unconnected port information for reporting */
                                QSocGenerateReportUnconnected::UnconnectedPortInfo portInfo;
                                portInfo.instanceName = instanceName;
                                portInfo.moduleName   = moduleName;
                                portInfo.portName     = portName;
                                portInfo.direction    = direction;

                                /* Clean the type for reporting - combine width and base type */
                                if (width.isEmpty()) {
                                    portInfo.type = "logic";
                                } else {
                                    portInfo.type = QString("logic%1").arg(width);
                                }

                                unconnectedPortReporter.addUnconnectedPort(portInfo);

                                /* Format FIXME message with width if available */
                                if (width.isEmpty()) {
                                    portConnections.append(
                                        QString("        .%1(/* FIXME: %2 %3 missing */)")
                                            .arg(portName)
                                            .arg(direction)
                                            .arg(portName));
                                } else {
                                    portConnections.append(
                                        QString("        .%1(/* FIXME: %2 %3 %4 missing */)")
                                            .arg(portName)
                                            .arg(direction)
                                            .arg(width)
                                            .arg(portName));
                                }
                            }
                        }
                    }
                } else {
                    qWarning() << "Warning: Module" << moduleName << "has no valid port section";
                }
            } else {
                qWarning() << "Warning: Failed to get module definition for" << moduleName;

                /* Fall back to existing connections if module definition not available */
                if (instancePortConnections.contains(instanceName)) {
                    const QMap<QString, QString>  &portMap = instancePortConnections[instanceName];
                    QMapIterator<QString, QString> portIter(portMap);
                    while (portIter.hasNext()) {
                        portIter.next();
                        portConnections.append(
                            QString("        .%1(%2)").arg(portIter.key()).arg(portIter.value()));
                    }
                }
            }

            if (portConnections.isEmpty()) {
                /* No port connections found for this instance */
                out << "        /* No port connections found for this instance */\n";
            } else {
                out << portConnections.join(",\n") << "\n";
            }

            out << "    );\n";
        }
    }

    /* Generate combinational logic after module instantiations */
    if (!generateCombPrimitive(netlistData, out)) {
        qWarning() << "Failed to generate combinational logic primitives";
        return false;
    }

    /* Generate sequential logic after combinational logic */
    if (!generateSeqPrimitive(netlistData, out)) {
        qWarning() << "Failed to generate sequential logic primitives";
        return false;
    }

    /* NOTE: FSM, reset, and clock primitive modules are now generated 
     * at file level before the top-level module. No inline generation needed. */

    /* Close module */
    out << "\nendmodule\n";

    outputFile.close();
    qInfo() << "Successfully generated Verilog file:" << outputFilePath;

    /* Generate unconnected port report if we have unconnected ports */
    if (unconnectedPortReporter.getUnconnectedPortCount() > 0) {
        const QString reportOutputPath = projectManager->getOutputPath();
        if (unconnectedPortReporter.generateReport(reportOutputPath, outputFileName)) {
            qInfo() << "Successfully generated unconnected port report:"
                    << QDir(reportOutputPath).filePath(outputFileName + ".nc.rpt");
        } else {
            qWarning() << "Failed to generate unconnected port report";
        }
    }

    /* Format generated Verilog file if verible-verilog-format is available */
    formatVerilogFile(outputFilePath);

    return true;
}

bool QSocGenerateManager::formatVerilogFile(const QString &filePath)
{
    /* Check if verible-verilog-format tool is available in the system */
    QProcess which;
    which.start("which", QStringList() << "verible-verilog-format");
    which.waitForFinished();

    if (which.exitCode() != 0) {
        /* Tool not found, silently return */
        qDebug() << "verible-verilog-format not found, skipping formatting";
        return false;
    }

    /* Tool found, proceed with formatting */
    qInfo() << "Formatting Verilog file using verible-verilog-format...";

    QProcess formatter;
    /* clang-format off */
    const QString argsStr = QStaticStringWeaver::stripCommonLeadingWhitespace(R"(
        --inplace
        --column_limit 119
        --indentation_spaces 4
        --line_break_penalty 4
        --wrap_spaces 4
        --port_declarations_alignment align
        --port_declarations_indentation indent
        --formal_parameters_alignment align
        --formal_parameters_indentation indent
        --assignment_statement_alignment align
        --enum_assignment_statement_alignment align
        --class_member_variable_alignment align
        --module_net_variable_alignment align
        --named_parameter_alignment align
        --named_parameter_indentation indent
        --named_port_alignment align
        --named_port_indentation indent
        --struct_union_members_alignment align
    )");
    /* clang-format on */

    QStringList args = argsStr.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);
    args << filePath;

    formatter.start("verible-verilog-format", args);
    formatter.waitForFinished();

    if (formatter.exitCode() == 0) {
        qInfo() << "Successfully formatted Verilog file";
        return true;
    }
    qWarning() << "Error formatting Verilog file:" << formatter.errorString();
    return false;
}

bool QSocGenerateManager::generateCombPrimitive(const YAML::Node &netlistData, QTextStream &out)
{
    if (!combPrimitive) {
        qWarning() << "Comb primitive generator not initialized";
        return false;
    }

    return combPrimitive->generateCombLogic(netlistData, out);
}

/**
 * @brief Generate FSM Verilog code for a single FSM
 * @param fsmItem The YAML node containing the FSM specification
 * @param out Output text stream
 */
bool QSocGenerateManager::generateFSMPrimitive(const YAML::Node &fsmNode, QTextStream &out)
{
    if (!fsmPrimitive) {
        qWarning() << "FSM primitive generator not initialized";
        return false;
    }

    return fsmPrimitive->generateFSMVerilog(fsmNode, out);
}

bool QSocGenerateManager::generateResetPrimitive(const YAML::Node &resetNode, QTextStream &out)
{
    if (!resetPrimitive) {
        qWarning() << "Reset primitive generator not initialized";
        return false;
    }

    return resetPrimitive->generateResetController(resetNode, out);
}

bool QSocGenerateManager::generateClockPrimitive(const YAML::Node &clockNode, QTextStream &out)
{
    if (!clockPrimitive) {
        qWarning() << "Clock primitive generator not initialized";
        return false;
    }

    return clockPrimitive->generateClockController(clockNode, out);
}

bool QSocGenerateManager::generateSeqPrimitive(const YAML::Node &netlistData, QTextStream &out)
{
    if (!seqPrimitive) {
        qWarning() << "Seq primitive generator not initialized";
        return false;
    }

    return seqPrimitive->generateSeqLogic(netlistData, out);
}
